// Some of the code comes from WebComponents.JS
// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
    switch (arguments.length) {
        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
    }
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Injectable } from 'angular2/di';
import { RegExpWrapper, StringWrapper } from 'angular2/src/core/facade/lang';
import { UrlResolver } from 'angular2/src/core/services/url_resolver';
/**
 * Rewrites URLs by resolving '@import' and 'url()' URLs from the given base URL,
 * removes and returns the @import urls
 */
export let StyleUrlResolver = class {
    constructor(_resolver) {
        this._resolver = _resolver;
    }
    resolveUrls(cssText, baseUrl) {
        cssText = this._replaceUrls(cssText, _cssUrlRe, baseUrl);
        return cssText;
    }
    extractImports(cssText) {
        var foundUrls = [];
        cssText = this._extractUrls(cssText, _cssImportRe, foundUrls);
        return new StyleWithImports(cssText, foundUrls);
    }
    _replaceUrls(cssText, re, baseUrl) {
        return StringWrapper.replaceAllMapped(cssText, re, (m) => {
            var pre = m[1];
            var originalUrl = m[2];
            if (RegExpWrapper.test(_dataUrlRe, originalUrl)) {
                // Do not attempt to resolve data: URLs
                return m[0];
            }
            var url = StringWrapper.replaceAll(originalUrl, _quoteRe, '');
            var post = m[3];
            var resolvedUrl = this._resolver.resolve(baseUrl, url);
            return pre + "'" + resolvedUrl + "'" + post;
        });
    }
    _extractUrls(cssText, re, foundUrls) {
        return StringWrapper.replaceAllMapped(cssText, re, (m) => {
            var originalUrl = m[2];
            if (RegExpWrapper.test(_dataUrlRe, originalUrl)) {
                // Do not attempt to resolve data: URLs
                return m[0];
            }
            var url = StringWrapper.replaceAll(originalUrl, _quoteRe, '');
            foundUrls.push(url);
            return '';
        });
    }
};
StyleUrlResolver = __decorate([
    Injectable(), 
    __metadata('design:paramtypes', [UrlResolver])
], StyleUrlResolver);
export class StyleWithImports {
    constructor(style, styleUrls) {
        this.style = style;
        this.styleUrls = styleUrls;
    }
}
var _cssUrlRe = /(url\()([^)]*)(\))/g;
var _cssImportRe = /(@import[\s]+(?:url\()?)['"]?([^'"\)]*)['"]?(.*;)/g;
var _quoteRe = /['"]/g;
var _dataUrlRe = /^['"]?data:/g;
//# sourceMappingURL=style_url_resolver.js.map